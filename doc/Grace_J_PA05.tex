\documentclass[12pt, a4paper, oneside]{article}
\usepackage[english]{babel}
\usepackage{xcolor,listings}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{datetime}
\usepackage{graphicx}
% For fitting table to page
\usepackage{adjustbox}
% For pseudocode
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother
%

\setlength{\parindent}{0pt}

\begin{document}
\title{PA05}
\author{Jayson Grace}
\date{\today}%
\maketitle

\pagenumbering{gobble}

\pagebreak
\pagenumbering{arabic}

\centerline{\author{\textbf{Jayson Grace}}}

\subsection*{Problem 1a}
Upon running the code, I was able to determine that the balance was not what I was expecting it to be. Instead of staying at the initial balance of 200, it would either be too big or too small. After inspecting the code, I saw that there were a number of floating point calculations happening between the calculation of balances A and B:

\begin{lstlisting}
 25       Bank.balance[0] = tmp1 + rint;
 26       for (j = 0; j < rint * 100; j++)
 27       {
 28         dummy = 2.345 * 8.765 / 1.234;
 29       }
 30       Bank.balance[1] = tmp2 - rint;
\end{lstlisting}

To determine if this was causing an issue, I moved the Balance calculation for B above the loop:

\begin{lstlisting}
 25       Bank.balance[0] = tmp1 + rint;
 26       Bank.balance[1] = tmp2 - rint;
 27       for (j = 0; j < rint * 100; j++)
 28       {
 29         dummy = 2.345 * 8.765 / 1.234;
 30       }
 \end{lstlisting}
 
This almost nearly eliminated any issues that I was seeing before, with a few exceptions that were very small discrepancies. \\

After looking at the code a bit more, I came to realize that the variable balance is shared between the two threads that we create while running the program. \\

To confirm this might be causing an issue, I used valgrind:
\begin{lstlisting}
valgrind --tool=helgrind ./race -v
\end{lstlisting}

The threads accessing the variable without any protection appear to be the catalyst of the sporadic behavior I saw when executing the program. The behavior became less prevalent when I took the latency being introduced by all of the floating point calculations out of the equation, but it did not completely resolve the issue. In fact, this issue will persist until a form of protection is introduced into the program.

\subsection*{Problem 1b}

\begin{lstlisting}
#include <pthread.h>

typedef struct
{
    int S;
    pthread_mutex_t mut;
    pthread_cond_t cond;
} Sem437;

void Sem437Init(Sem437*, int);
void Sem437P(Sem437*);
void Sem437V(Sem437*);

/**
* @brief Used to initialize the mutex and condition variable
* @param sem semaphore to initialize
* @param i value to associate with the semaphore
*/
void Sem437Init(Sem437* sem, int i)
{
    sem->S = i;
    pthread_mutex_init(&sem->mut, NULL);
    pthread_cond_init(&sem->cond, NULL);
}

/**
* @brief Used for decrementing
* @param sem semaphore to decrement
*/
void Sem437P(Sem437* sem)
{
    pthread_mutex_lock(&sem->mut);
    // If semaphore is negative, block
    while(sem->S <= 0)
        pthread_cond_wait(&sem->cond, &sem->mut);
    sem->S -= 1;
    pthread_mutex_unlock(&sem->mut);
}

/**
* @bried Used for incrementing
* @param sem semaphore to increment
*/
void Sem437V(Sem437* sem)
{
    pthread_mutex_lock(&sem->mut);
    sem->S += 1;
    pthread_cond_signal(&sem->cond);
    pthread_mutex_unlock(&sem->mut);
}
\end{lstlisting}

\end{document}